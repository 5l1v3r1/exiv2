#include "gtestwrapper.h"

#include "gtest_helpers.hpp"

#include "exiv2/error.hpp"
#include "exiv2/jp2image.hpp"

using namespace Exiv2;

struct FakeJp2Image
{
    // static const byte signature_[];
};

/// copy pasta from jp2image.cpp
static const unsigned char Jp2Signature[12] = {0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a};

/// copy pasta from jp2image.cpp
static const unsigned char Jp2Blank[] = {
    0x00, 0x00, 0x00, 0x0c, 0x6a, 0x50, 0x20, 0x20, 0x0d, 0x0a, 0x87, 0x0a, 0x00, 0x00, 0x00, 0x14, 0x66, 0x74,
    0x79, 0x70, 0x6a, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x2d,
    0x6a, 0x70, 0x32, 0x68, 0x00, 0x00, 0x00, 0x16, 0x69, 0x68, 0x64, 0x72, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x01, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x63, 0x6f, 0x6c, 0x72, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x70, 0x32, 0x63, 0xff, 0x4f, 0xff, 0x51, 0x00,
    0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x07, 0x01, 0x01, 0xff, 0x64, 0x00, 0x23, 0x00, 0x01, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x3a,
    0x20, 0x4a, 0x61, 0x73, 0x50, 0x65, 0x72, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x31, 0x2e,
    0x39, 0x30, 0x30, 0x2e, 0x31, 0xff, 0x52, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x04, 0x04, 0x00,
    0x01, 0xff, 0x5c, 0x00, 0x13, 0x40, 0x40, 0x48, 0x48, 0x50, 0x48, 0x48, 0x50, 0x48, 0x48, 0x50, 0x48, 0x48,
    0x50, 0x48, 0x48, 0x50, 0xff, 0x90, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x01, 0xff, 0x5d,
    0x00, 0x14, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xff, 0x93, 0xcf, 0xb4, 0x04, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xff, 0xd9};

struct EncodeJp2Header : ::testing::Test
{
    DataBuf boxBuf_;
};

struct aJp2Image : public ::testing::Test
{
    aJp2Image() : mockIo_(new MemIo)
    {
        this->mockIo_->open();
    }

    MemIo::AutoPtr mockIo_;
};

struct Jp2ImageWriteMetadata : public aJp2Image
{
};

TEST_F(aJp2Image, freshImageEqualsBlank)
{
    Jp2Image img(this->mockIo_, true);
    img.io().seek(0, BasicIo::beg);
    for (size_t i = 0; i < EXV_COUNTOF(Jp2Blank); ++i) {
        ASSERT_EQ(Jp2Blank[i], img.io().getb());
    }
    ASSERT_EQ(img.io().getb(), EOF);
}

TEST_F(aJp2Image, writeFailsOnClosedIo)
{
    FileIo::AutoPtr fileIo(new FileIo("dummy_file"));
    ASSERT_FALSE(fileIo->isopen());

    Jp2Image img(fileIo, true);
    ASSERT_THROW_ERROR_CODE(img.writeMetadata(), kerDataSourceOpenFailed);
}

TEST_F(aJp2Image, writeEmptyMetadata)
{
    Jp2Image img(this->mockIo_, true);
    ASSERT_NO_THROW(img.writeMetadata());

    // taken from img.io(), need to reconstruct this & find out whether it is actually sane
    static const byte expected_output[] = {
        0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A, 0x00, 0x00, 0x00, 0x14, 0x66, 0x74,
        0x79, 0x70, 0x6A, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x6A, 0x70, 0x32, 0x20, 0x00, 0x00, 0x00, 0x2D,
        0x6A, 0x70, 0x32, 0x68, 0x00, 0x00, 0x00, 0x16, 0x69, 0x68, 0x64, 0x72, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x01, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x63, 0x6F, 0x6C, 0x72, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x6A, 0x70, 0x32, 0x63, 0xFF, 0x4F, 0xFF, 0x51, 0x00,
        0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x07, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x23, 0x00, 0x01, 0x43, 0x72, 0x65, 0x61, 0x74, 0x6F, 0x72, 0x3A,
        0x20, 0x4A, 0x61, 0x73, 0x50, 0x65, 0x72, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x31, 0x2E,
        0x39, 0x30, 0x30, 0x2E, 0x31, 0xFF, 0x52, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x05, 0x04, 0x04, 0x00,
        0x01, 0xFF, 0x5C, 0x00, 0x13, 0x40, 0x40, 0x48, 0x48, 0x50, 0x48, 0x48, 0x50, 0x48, 0x48, 0x50, 0x48, 0x48,
        0x50, 0x48, 0x48, 0x50, 0xFF, 0x90, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x01, 0xFF, 0x5D,
        0x00, 0x14, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0x93, 0xCF, 0xB4, 0x04, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFF, 0xD9};

    for (size_t i = 0; i < EXV_COUNTOF(expected_output); ++i) {
        ASSERT_EQ(img.io().getb(), expected_output[i]);
    }
    ASSERT_EQ(img.io().getb(), EOF);
}

TEST_F(Jp2ImageWriteMetadata, notAJp2Img)
{
    static const byte invalid_jp2signature[12] = {0xde, 0xad, 0xbe, 0xef, 0xde, 0xad,
                                                  0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef};
    this->mockIo_->write(invalid_jp2signature, EXV_COUNTOF(invalid_jp2signature));
    Jp2Image img(this->mockIo_, false);

    ASSERT_THROW_ERROR_CODE(img.writeMetadata(), kerNoImageInInputData);
}
